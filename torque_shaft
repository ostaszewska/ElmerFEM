shaft.sif
1

module ReluctInterp
 contains 

  function LinInterpSimple(x0) RESULT(y0)
	USE Types 
	IMPLICIT None
	real(kind=dp) :: x0, y0

        y0 = 769d0 + 4.7516d0*x0*1d-6

  end function LinInterpSimple


  function LinInterp(x0i) RESULT(y0)
	USE Types 
	IMPLICIT None
	real(kind=dp) :: x0, x0i, y0
	real, Dimension(69) :: xT, yT
	integer :: i
      
	x0=x0i / 1d6		! Convert to MPa

	xT = [-5.00, -4.75, -4.50, -4.25, -4.00, -3.75, -3.50, -3.25, -3.00, -2.75, -2.50, &
	      -2.25, -2.00, -1.75, -1.50, -1.25, -1.00, -0.75, -0.50, -0.25, 0.00, 0.25, &
	      0.50, 0.75, 1.00, 1.25, 1.50, 1.75, 2.00, 2.25, 2.50, 2.75, 3.00, 3.25, 3.50, &
              3.75, 4.00, 4.25, 4.50, 4.75, 5.00, 5.25, 5.50, 5.75, 6.00, 6.25, 6.50, 6.75, &
              7.00, 7.25, 7.50, 7.75, 8.00, 8.25, 8.50, 8.75, 9.00, 9.25, 9.50, 9.75, 10.00, &
              10.25, 10.50, 10.75, 11.00, 11.25, 11.50, 11.75, 12.00] 

	yT = [4870.0, 4871.6, 4874.0, 4876.8, 4880.0, 4883.6, 4887.9, 4893.3, 4900.0, 4910.2, &
	     4924.8, 4941.9, 4960.0, 4979.3, 5000.9, 5024.6, 5050.0, 5075.1, 5101.2, 5132.9, &
	     5175.0, 5251.9, 5353.9, 5456.5, 5541.7, 5630.1, 5746.7, 5859.8, 5929.8, 5995.8, &
             6069.8, 6159.0, 6288.2, 6370.2, 6469.1, 6565.3, 6644.1, 6700.5, 6734.0, 6773.6, &
             6804.1, 6808.9, 6802.3, 6775.0, 6670.0, 6592.6, 6522.8, 6459.2, 6400.0, 6343.5, &
             6290.0, 6241.6, 6200.0, 6164.7, 6133.2, 6105.2, 6080.0, 6055.5, 6032.0, 6012.5, &
             6000.0, 5993.0, 5987.7, 5983.5, 5980.0, 5976.8, 5974.0, 5971.6, 5970.0]
	
	if (x0 .LT. xT(1)) then
	   y0=yT(1)

	else if (x0 .GT. xT(69)) then
           y0=yT(69)

	else

	  i=floor(1+(x0+5)/0.25)
	  y0=yT(i)+(x0-xT(i))*(yT(i+1)-yT(i))/(xT(i+1)-xT(i))

	end if

  end function LinInterp


  function Matrix3x3Inv(Ri) RESULT(Ro)
	USE Types 
	IMPLICIT None
	real(kind=dp), Dimension (3,3) :: Ri, Ro
	real(kind=dp) :: Det, s

  Det = Ri(1,1)*Ri(2,2)*Ri(3,3)-Ri(1,1)*Ri(2,3)*Ri(3,2)- & 
        Ri(1,2)*Ri(2,1)*Ri(3,3)+Ri(1,2)*Ri(2,3)*Ri(3,1)+ & 
        Ri(1,3)*Ri(2,1)*Ri(3,2)-Ri(1,3)*Ri(2,2)*Ri(3,1)		! direct calculatios version

  if (Det .NE. 0) then
     s = 1d0 / Det
  else
     s = 1d25
  end if
    
  Ro(1,1) =  s *   (Ri(2,2)*Ri(3,3) - Ri(3,2)*Ri(2,3))
  Ro(2,1) = -1*s * (Ri(2,1)*Ri(3,3) - Ri(3,1)*Ri(2,3))
  Ro(3,1) =  s *   (Ri(2,1)*Ri(3,2) - Ri(3,1)*Ri(2,2))
    
  Ro(1,2) = -1*s * (Ri(1,2)*Ri(3,3) - Ri(3,2)*Ri(1,3))
  Ro(2,2) =  s *   (Ri(1,1)*Ri(3,3) - Ri(3,1)*Ri(1,3))
  Ro(3,2) = -1*s * (Ri(1,1)*Ri(3,2) - Ri(3,1)*Ri(1,2))

  Ro(1,3) =  s *   (Ri(1,2)*Ri(2,3) - Ri(2,2)*Ri(1,3))
  Ro(2,3) = -1*s * (Ri(1,1)*Ri(2,3) - Ri(2,1)*Ri(1,3))
  Ro(3,3) =  s *   (Ri(1,1)*Ri(2,2) - Ri(2,1)*Ri(1,2))

  end function Matrix3x3Inv



end module ReluctInterp

!-------------------------------------------------------------------------------

SUBROUTINE reluct_func(Model, n, X, Y)

  USE DefUtils
  USE ReluctInterp

  IMPLICIT NONE
  TYPE(Model_t) :: Model
  INTEGER :: n
  REAL(KIND=dp) :: X(*)
  REAL(KIND=dp), POINTER CONTIG :: Y(:,:)
  
  REAL(KIND=dp) :: PSx, PSy, PSz, mi0, v
  REAL(KIND=dp) :: ssx, ssy, ssz
  REAL(KIND=dp) :: mirx, miry, mirz, mix, miy, miz
  REAL(KIND=dp) :: relx, rely, relz

  Real(KIND=dp), dimension (3,3) :: reluct, reluctT, PA


  PSx = X(1)
  PSy = X(2)
  PSz = X(3)			! receive principal stresses


  PA(1,1) = COS(X(4))
  PA(2,1) = COS(X(5))
  PA(3,1) = COS(X(6))
		
  PA(1,2) = COS(X(7))
  PA(2,2) = COS(X(8))		
  PA(3,2) = COS(X(9))

  PA(1,3) = COS(X(10))		
  PA(2,3) = COS(X(11))
  PA(3,3) = COS(X(12))		!  receive angles


! -- end of variable import --

  mi0 = 1.256637061436d-06   	! mi0=4*3.14159265359*1e-7
  v = 3d-1			! Poison ration

  ssx = PSx-v*PSy-v*PSz
  ssy = PSy-v*PSx-v*PSz
  ssz = PSz-v*PSx-v*PSy		! effective stresses calculated from principal stresses 

  mirx = LinInterpSimple(ssx)
  miry = LinInterpSimple(ssy)
  mirz = LinInterpSimple(ssz)

!  mirx = LinInterp(ssx)
!  miry = LinInterp(ssy)
!  mirz = LinInterp(ssz)	! values of diagonal tensor of relative permeability
				! determined from linear interpolation in function LinInterp

  if (mirx .LT. 20) then 
     mirx = 20
  end if
  if (miry .LT. 20) then 
     miry = 20
  end if
  if (mirz .LT. 20) then 
     mirz = 20
  end if			! limit lower value of relative permeabiltity to 20


  mix = mi0*mirx
  miy = mi0*miry
  miz = mi0*mirz		! calculate the permeability


  relx = 1/mix
  rely = 1/miy
  relz = 1/miz			! calculate diagonal values of reluctivity tensor


  reluctT(1,1) = relx
  reluctT(2,2) = rely
  reluctT(3,3) = relz		! reluctivity tensor matrix
  
  reluctT(1,2) = 0d0
  reluctT(1,3) = 0d0
  reluctT(2,1) = 0d0
  reluctT(2,3) = 0d0
  reluctT(3,1) = 0d0
  reluctT(3,2) = 0d0		! set zeros to other

 
 ! rotation matrix R = PA

  reluct=MatMul(PA,MatMul(reluctT,Matrix3x3Inv(PA)))	 ! rotation of tensor reluctT by rotation matrix R
							 ! reluct = R * teluctT * R'

! -- export variables --

  Y(1,1)=reluct(1,1)
  Y(1,2)=reluct(1,2)
  Y(1,3)=reluct(1,3)

  Y(2,1)=reluct(2,1)
  Y(2,2)=reluct(2,2)
  Y(2,3)=reluct(2,3)

  Y(3,1)=reluct(3,1)
  Y(3,2)=reluct(3,2)
  Y(3,3)=reluct(3,3)

END SUBROUTINE reluct_func


#
## Shaft for torque
#
algebraic3d

# shaft core

solid ShaftOut = cylinder ( 0, 0, -45; 0, 0, 45; 1.25)
	and plane (0, 0, -16; 0, 0, -1)
	and plane (0, 0,  16; 0, 0, 1);

solid ShaftIn = cylinder ( 0, 0, -50; 0, 0, 50; 0.125)
	and plane (0, 0, -17; 0, 0, -1)
	and plane (0, 0,  17; 0, 0, 1);

solid Shaft = ShaftOut and not ShaftIn -maxh=0.125;


# magnetizing coil

solid MagCoilOut = cylinder ( 0, 0, -45; 0, 0, 45; 2.5)
	and plane (0, 0, -16; 0, 0, -1)
	and plane (0, 0,  16; 0, 0, 1);
	
solid MagCoilIn = cylinder ( 0, 0, -50; 0, 0, 50; 1.75)
	and plane (0, 0, -17; 0, 0, -1)
	and plane (0, 0,  17; 0, 0, 1);

solid MagCoil = MagCoilOut and not MagCoilIn -maxh=0.75;




# sensing coil

solid SensCoilOut = cylinder (0, 0, -7; 0, 0, 7; 3.75)
	and plane (0, 0, -3; 0, 0, -1)
	and plane (0, 0,  3; 0, 0, 1);

solid SensCoilIn = cylinder (0, 0, -8; 0, 0, 8; 3)
	and plane (0, 0, -4; 0, 0, -1)
	and plane (0, 0,  4; 0, 0, 1);

solid SensCoil = SensCoilOut and not SensCoilIn -maxh=0.75;


# Sphere

solid Range = sphere (0, 0, 0; 160) 
	 and not Shaft
	 and not MagCoil
	 and not SensCoil; # -maxh=30;  # 0.2


tlo Shaft -col=[0,0,1];

tlo MagCoil -col=[0,1,0];

tlo SensCoil -col=[1,0,0];

tlo Range -col=[0.5,0,0.5] -transparent;

$ I_tot = 37.5		! total current in driving coil Amper-turns (pol. prado-zwoje)
$ R_tot = 10e3		! total resistance of sensing coil
$ M_tot = 1.6

! --- initial calculations section ---

! cross-section of driving coil S_sens = 0.75 mm * 32 mm = 24 mm2 = 24 * 10^-6 =  2.4e-5 m2
$ I_dens = I_tot / 2.4e-5

! cross-section of the sensing coil S_sens = = 6 mm * 0.75 mm = 4.5 * 10^-6 =  0.45e-5 m2
! length of the sensing coil L_sens = 2 * pi * 3.375 mm = 2 * pi * 0.003375 = 0.0212 m
! resistivity of the sensing coil  ro = R * S_sens / L_sens
! conductivity = 1 / resistivity

$ Cond_v = 1/(R_tot * 0.45e-5 / 0.0212)


! setup geometry
$ R1 = 0.000125
$ R2 = 0.00125

! sigma_s = M_tot / (2*pi* (R2^3/3 - R1^3/3))

$ sigma_s = M_tot / (2.094395102 * (R2^3-R1^3))





! frequency calculations
$ freq_t = 2000  ! 200  Hz
$ ang_freq_t = 6.283185307 * freq_t



Header
  CHECK KEYWORDS Warn
  Mesh DB "." "shaft"
  Include Path ""
  Results Directory ""
End

Simulation
  Max Output Level = 5
  Coordinate System = Cartesian
  Coordinate Mapping(3) = 1 2 3
  Angular Frequency = $ang_freq_t   ! angular frequency
  Simulation Type = Steady state
  Steady State Max Iterations = 1
  Output Intervals = 1
  Solver Input File = shaft.sif
  Post File = shaft.ep
End

Constants
  Gravity(4) = 0 -1 0 9.82
  Stefan Boltzmann = 5.67e-08
  Permittivity of Vacuum = 8.8542e-12
  Boltzmann Constant = 1.3807e-23
  Unit Charge = 1.602e-19
End

! ------ MATERIALS --------

Material 1
  Name = "Air"
!  Relative Permittivity = Real 1.00059
  Electric Conductivity = Real 0.0
  Relative Permeability = Real 1.0
End

Material 2
  Name = "Steel"
  Poisson ratio = Real 0.3
  Youngs modulus = Real 200.0e9
  Electric Conductivity = Real 1.0e7

Reluctivity(3,3) = Variable "Principal Stress", "Principal Angle"
		Real procedure "file_reluct" "reluct_func"

!Reluctivity(3,3) = 80 0 0 0 80 0 0 0 80 

Reluctivity Im(3,3) = 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0

!	Relative Permeability = Variable "Magnetic Field Strength 1", "Magnetic Field Strength 2", "Magnetic Field Strength 3"
!        Real MATC "x=tx(0);y=tx(1);z=tx(2);H=sqrt(x^2+y^2+z^2);if(H<1998.232738) {769} else {1536640.9756/H}"

End

Material 3
  Name = "Copper"
  Electric Conductivity = Real 0.0 ! 6.0e7
  Relative Permeability = Real 1.0
End

Material 4
  Name = "Resistor"
  Electric Conductivity = $Cond_v
  Relative Permeability = Real 1.0
End

! ------- BODIES ----------

Body 1
  Target Bodies(1) = 1
  Name = "Shaft"
  Material = 2
  Equation = 1

End

Body 2
  Target Bodies(1) = 2
  Name = "Coil_drv"
  Material = 3
  Equation = 2
  Body Force = 1
End

Body 3
  Target Bodies(1) = 3
  Name = "Coil_sens"
  Material = 4
  Equation = 2
End

Body 4
  Target Bodies(1) = 4
  Name = "Sphere"
  Material = 1
  Equation = 2
End

! -------- EQUATIONS ----------
Equation 1
	Name = "mech_magn"
	Active Solvers (5) =  1 2 3 4 5
End

Equation 2
	Name = "magn"
	Active Solvers (4) =  2 3 4 5
End

! --------- SOLVERS --------

Solver 1
  Equation = Linear elasticity
  Procedure = "StressSolve" "StressSolver"
  Variable = -dofs 3 Displacement
  Exec Solver = before simulation ! Always
!  Element = p:2

!  Stabilize = True
!  Bubbles = False
!  Lumped Mass Matrix = False
!  Optimize Bandwidth = True
!  Steady State Convergence Tolerance = 9.0e-6
!  Nonlinear System Convergence Tolerance = 1.0e-11
!  Nonlinear System Max Iterations = 1
!  Nonlinear System Newton After Iterations = 3
!  Nonlinear System Newton After Tolerance = 1.0e-11
!  Nonlinear System Relaxation Factor = 1
!  Linear System Solver = Iterative
!  Linear System Iterative Method = CG ! BiCGStabl CGR
!  Linear System Max Iterations = 15000
!  Linear System Convergence Tolerance = 9.0e-6
!  BiCGstabl polynomial degree = 2
!  Linear System Preconditioning = ILU1
!  Linear System ILUT Tolerance = 1.0e-11
!  Linear System Abort Not Converged = False
!  Linear System Residual Output = 1
!  Linear System Precondition Recompute = 1



!  Variable DOFs = Integer 2
  Displace Mesh = Logical FALSE  !TRUE   

  Linear System Solver = Direct
  Linear System Symmetric = Logical True
  Linear System Scaling = Logical False
  Linear System Iterative Method = BiCGStab
  Linear System Direct Method = MUMPS ! UMFPACK
  Linear System Convergence Tolerance = 1.0e-10
  Linear System Max Iterations = 200
  Linear System Preconditioning = ILU2

  Nonlinear System Convergence Tolerance = Real 1.0e-12
  Nonlinear System Max Iterations = Integer 1
  Nonlinear System Relaxation Factor = Real 1

  Steady State Convergence Tolerance= 1.0e-7
  Optimize Bandwidth = True


! Fix Displacements = True

  Calculate Strains = True
  Calculate Principal = True
  Calculate Stresses = True
  Calculate Pangle = True

End

Solver 2
  Equation = "MGDynamics"

  Variable = "AV[AV re:1 AV im:1]"
  Procedure = "MagnetoDynamics" "WhitneyAVHarmonicSolver"

  Linear System Symmetric = True
  Linear System Solver = "Iterative"
  Linear System Preconditioning = none
  Linear System Residual Output = 50
  Linear System Max Iterations = 10000
  Linear System Iterative Method = BiCGStabl
  !GCR
  Linear System Convergence Tolerance = 5.0e-6
  BicgStabl Polynomial Degree = 4
End



Solver 3
  Equation = "MGDynamicsCalc"

  Procedure = "MagnetoDynamics" "MagnetoDynamicsCalcFields"
  Linear System Symmetric = True

  Potential Variable = String "AV"

  Calculate Current Density = Logical True
  Calculate Electric Field = Logical True
  Calculate Magnetic Field Strength = Logical True
  Calculate Joule Heating = True

  Steady State Convergence Tolerance = 0
  Linear System Solver = "Iterative"
  Linear System Preconditioning = None
  Linear System Residual Output = 0
  Linear System Max Iterations = 5000
  Linear System Iterative Method = CG
  Linear System Convergence Tolerance = 5.0e-6

!  Calculate Nodal Fields = Logical False
!  Impose Body Force Potential = Logical True
!  Impose Body Force Current = Logical True

!  Discontinuous Bodies = True
!  calculate harmonic peak power = logical true

  Calculate Magnetic Vector Potential = Logical True
  Calculate Current Density = Logical True
  Calculate Joule Heating = Logical True
  Calculate Electric Field = Logical True
  Calculate Magnetic Flux Density = Logical True
  Calculate Magnetic Field Strength = Logical True

End

Solver 4
	Exec Solver = after simulation
	Equation = SaveGrid
	Procedure = "SaveGridData" "SaveGridData"
	Filename Prefix = String sensing_current
	Output Format = String table
	Check for Duplicates = Logical True

	Grid nx = Integer 25
	Grid ny = Integer 1
	Grid nz = Integer 25
	
	Min Coordinate 1 = Real  0.003
	Min Coordinate 2 = Real -0.001
	Min Coordinate 3 = Real -0.003

	Max Coordinate 1 = Real  0.00375
	Max Coordinate 2 = Real  0.001
	Max Coordinate 3 = Real  0.003

	Vector Field 1 = String Current Density Re E
	Vector Field 2 = String Current Density Im E


End

Solver 5
  	Exec Solver =  After simulation
  	Equation = "result output"
  	Procedure = "ResultOutputSolve" "ResultOutputSolver"
  	Save Geometry Ids = Logical True ! add this line if you want to access boundaries in Paraview
  	Output File Name = File "shaft.vtu"
  	Output Format = String vtu
End



!---------BODY FORCE------
Body Force 1
	Name = "Solenoid Current Density"

	! tx(0) - x
	! tx(1) - y
	! tx(2) - z
	! tx(3) - t
	Current Density 1 = Variable coordinate
		Real MATC "x=tx(0); y=tx(1); r=sqrt(x*x+y*y); -1*I_dens*y/r"
	Current Density 2 = Variable coordinate
		Real MATC "x=tx(0); y=tx(1); r=sqrt(x*x+y*y); I_dens*x/r"
End


! ------- BOUNDARY CONDITIONS -------


Boundary condition 1
  name = "Far"
  target boundaries(1) = 13
  AV re {e} 1 = 0
  AV re {e} 2 = 0
  AV re {e} 3 = 0
  AV im {e} 1 = 0
  AV im {e} 2 = 0
  AV im {e} 3 = 0
End

Boundary condition 2
  name = "Torque_Zplus"
  target boundaries (1) = 11
!Force 3 = 2

	! tx(0) - x
	! tx(1) - y
	! tx(2) - z
	! tx(3) - t

	Force 1 = Variable coordinate
		Real MATC "x=tx(0); y=tx(1); r=sqrt(x*x+y*y); -1*sigma_s*y/r"
	Force 2 = Variable coordinate
		Real MATC "x=tx(0); y=tx(1); r=sqrt(x*x+y*y); sigma_s*x/r"
End


Boundary condition 3
  name = "Torque_Zminus"
  target boundaries (1) =  2 ! xxxxxxxxxxxx
	! tx(0) - x
	! tx(1) - y
	! tx(2) - z
	! tx(3) - t

Displacement 1 = 0
Displacement 2 = 0
Displacement 3 = 0

!	Force 1 = Variable coordinate
!		Real MATC "x=tx(0); y=tx(1); r=sqrt(x*x+y*y); -1*sigma_s*y/r"
!	Force 2 = Variable coordinate
!		Real MATC "x=tx(0); y=tx(1); r=sqrt(x*x+y*y); sigma_s*x/r"
End


